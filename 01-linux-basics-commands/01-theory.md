# 01-theory.md: Linux Fundamentals and Core Concepts

## Table of Contents
1. [The Linux Filesystem](#the-linux-filesystem)
2. [Understanding Shells and Commands](#understanding-shells-and-commands)
3. [Users, Groups, and Permissions](#users-groups-and-permissions)
4. [Paths: Absolute and Relative](#paths-absolute-and-relative)
5. [Files and Directories](#files-and-directories)
6. [Command Structure and Syntax](#command-structure-and-syntax)
7. [Environment Variables](#environment-variables)
8. [Standard Streams: Input, Output, Error](#standard-streams-input-output-error)
9. [Pipes and Redirection](#pipes-and-redirection)
10. [Wildcards and Globbing](#wildcards-and-globbing)

---

## The Linux Filesystem

### Understanding the Filesystem Hierarchy

Linux uses a **unified filesystem** where everything is organized in a tree-like hierarchy starting from the root directory (`/`). Unlike Windows which has multiple drives (C:, D:, etc), Linux has ONE filesystem with everything connected to the root.

```
/                                    ← Root of everything
│
├── bin/              Essential command binaries (ls, cat, grep, etc)
├── boot/             Boot files and kernel
├── dev/              Device files (hard drives, USB, etc)
├── etc/              System configuration files
├── home/             Home directories for regular users
│   ├── alice/        Alice's home directory (/home/alice)
│   ├── bob/          Bob's home directory (/home/bob)
│   └── charlie/      Charlie's home directory (/home/charlie)
├── lib/              System libraries
├── media/            Removable media mount points
├── mnt/              Temporary filesystem mounts
├── opt/              Optional software (third-party apps)
├── proc/             Process information (virtual filesystem)
├── root/             Root user's home directory
├── run/              Runtime data
├── srv/              Service data
├── sys/              System information (virtual filesystem)
├── tmp/              Temporary files (cleared on reboot)
├── usr/              User programs and data
│   ├── bin/          User commands
│   ├── lib/          User libraries
│   ├── local/        Locally installed software
│   └── share/        Shared data
└── var/              Variable data
    ├── log/          Log files
    ├── cache/        Cached data
    └── spool/        Print jobs, mail, etc.
```

### Key Directories Explained

| Directory | Purpose | Example Contents |
|-----------|---------|-----------------|
| `/bin` | Essential command binaries | `ls`, `cat`, `grep`, `cp` |
| `/home` | User home directories | `/home/username/` for each user |
| `/root` | Root user's home | Files for the superuser |
| `/tmp` | Temporary files | Automatically cleaned periodically |
| `/etc` | Configuration files | `passwd`, `hostname`, `fstab` |
| `/var` | Variable data (logs, caches) | `/var/log/`, `/var/cache/` |
| `/usr` | User programs and data | Installed applications |
| `/opt` | Optional software | Third-party applications |
| `/dev` | Device files | `/dev/sda` (hard drive), `/dev/null` |

### Important Concepts

**Mount Points:** Directories where other filesystems are attached. For example:
- `/mnt/usb` - USB drive mounted here
- `/media/cdrom` - CD/DVD mounted here

**Virtual Filesystems:**
- `/proc` - Information about running processes
- `/sys` - System and kernel information
- These aren't real files - they're generated by the kernel

---

## Understanding Shells and Commands

### What is a Shell?

A **shell** is a program that interprets your commands and communicates with the operating system. It's the intermediary between you and the kernel (the core of the OS).

```
You type command
        ↓
Shell reads and interprets
        ↓
Shell sends instruction to kernel
        ↓
Kernel executes (runs program)
        ↓
Program produces output
        ↓
Shell displays output to you
```

### Common Shells

```
/bin/bash      ← Bourne Again Shell (most common, default in Ubuntu/Debian)
/bin/sh        ← Original Bourne Shell (minimal)
/bin/zsh       ← Z Shell (advanced, popular for power users)
/bin/ksh       ← Korn Shell (used in many enterprise systems)
/bin/fish      ← Friendly Interactive Shell (user-friendly)
```

**Check your current shell:**
```bash
echo $SHELL                # What shell am I using?
ps -p $$                   # Check process of current shell
cat /etc/shells            # What shells are available?
```

### How Commands Work

When you type a command, the shell:

1. **Reads** - Gets the command you typed
2. **Parses** - Breaks it into parts (command, options, arguments)
3. **Expands** - Handles wildcards, variables, redirections
4. **Executes** - Runs the program
5. **Waits** - Waits for it to finish (or background process)
6. **Reports** - Shows output and exit code

### Command Types

```
1. External Commands (programs on disk)
   ├─ /usr/bin/ls       → List files
   ├─ /bin/cat          → Show file contents
   └─ /usr/bin/grep     → Search text

2. Built-in Commands (part of the shell itself)
   ├─ cd                → Change directory
   ├─ echo              → Print text
   ├─ alias             → Create shortcut
   └─ export            → Set environment variable

3. Scripts (text files containing commands)
   ├─ #!/bin/bash       → Script files
   └─ Run if executable

4. Functions (commands you define)
   └─ my_function() { }
```

**Difference:** When you type `cd`, the shell itself changes directories. When you type `ls`, the shell executes the `/bin/ls` program.

---

## Users, Groups, and Permissions

### The Permission System

Every file has three sets of permissions for three categories of people:

```
-rw-r--r-- 1 alice users 1234 Jan 14 10:30 report.txt
│││││││││
││└──┴──┘ Others (everyone else): r-- (read only)
│└──┬──┘ Group (users group): r-- (read only)
└──┬─── Owner (alice): rw- (read and write, no execute)

Legend:
r = read (4)
w = write (2)
x = execute (1)
- = no permission (0)
```

### Permission Categories

```
Owner     → User who owns the file (usually the creator)
Group     → Set of users who can share permissions
Others    → Everyone else on the system
```

### Permission Types

```
r (Read)      → Permission to view/read file contents
w (Write)     → Permission to modify/edit file
x (Execute)   → Permission to run file as program
               (for directories: permission to list contents)
- (None)      → No permission
```

### Permission Numbers (Octal)

```
r = 4,  w = 2,  x = 1

rwx = 7  (4+2+1: read, write, execute)
rw- = 6  (4+2+0: read, write, no execute)
r-x = 5  (4+0+1: read, no write, execute)
r-- = 4  (4+0+0: read only)
-wx = 3  (0+2+1: write, execute, no read)
--x = 1  (0+0+1: execute only)
--- = 0  (0+0+0: no permissions)
```

### Common Permission Patterns

```
755 = rwxr-xr-x  (Owner: full, Others: read+execute)
       Used for: Programs and executable directories

644 = rw-r--r--  (Owner: read+write, Others: read only)
       Used for: Regular files and documents

700 = rwx------  (Owner: full, Others: nothing)
       Used for: Private files and directories

777 = rwxrwxrwx  (Everyone: full access)
       Used for: Shared temporary files (BE CAREFUL!)
```

### Users and Groups

```
/etc/passwd
└─ Contains: username, UID (user ID), home directory, shell

/etc/group
└─ Contains: group name, GID (group ID), members

/etc/shadow
└─ Contains: password hashes (protected file, root only)
```

**Example entry in /etc/passwd:**
```
alice:x:1000:1000:Alice Smith:/home/alice:/bin/bash
│     │  │    │    │          │              │
│     │  │    │    │          │              └─ Shell
│     │  │    │    │          └─ Home directory
│     │  │    │    └─ Comment (full name)
│     │  │    └─ Group ID
│     │  └─ User ID
│     └─ Password indicator (x = stored in /etc/shadow)
└─ Username
```

### Special Users

```
root (UID 0)      → Superuser, can do anything
                     Home: /root, Shell: /bin/bash

nobody            → Special user for running untrusted processes
                     Usually for services and daemons

system users      → Users for system services and daemons
                     UIDs typically < 1000
```

---

## Paths: Absolute and Relative

### Absolute Paths

An **absolute path** starts from the root (`/`) and describes the complete location:

```
/home/alice/documents/report.txt
│    │     │          │
│    │     │          └─ File name
│    │     └─ Directory (documents)
│    └─ User directory (alice)
└─ Root of filesystem
```

**Characteristics:**
- Always starts with `/`
- Valid from anywhere (same path regardless of current location)
- Unambiguous - exactly one file it refers to

**Examples:**
```bash
/usr/bin/python3      # Absolute path to python
/etc/hostname         # Absolute path to hostname config
/home/alice/file.txt  # Absolute path to a file
/tmp/test             # Absolute path to temp directory
```

### Relative Paths

A **relative path** is relative to your current directory:

```
If you're in /home/alice/ and want to access documents/report.txt:
- Absolute: /home/alice/documents/report.txt
- Relative:   documents/report.txt (shorter!)
```

**Special symbols:**
```
.         Current directory
..        Parent directory (one level up)
~         Home directory (shortcut)
```

**Examples from `/home/alice`:**
```bash
documents/report.txt      # Relative: report.txt in documents folder
../bob/file.txt          # Relative: file.txt in bob's folder (sibling)
../../etc/hostname       # Relative: go up 2 levels to /, then to etc
~/documents/report.txt   # Relative: same as /home/alice/documents/report.txt
./file.txt              # Relative: file.txt in current directory
```

### When to Use Which

```
Absolute Paths:
├─ In scripts (paths won't change if script runs from different location)
├─ In configuration files
└─ When path is fixed

Relative Paths:
├─ In command line for convenience
├─ When working in a specific directory
└─ For portable relative references
```

---

## Files and Directories

### File Attributes

Every file in Linux has several attributes:

```
inode          → Internal identifier (unique per filesystem)
Name           → Filename (what you type)
Type           → Regular file, directory, symlink, etc
Size           → How many bytes
Permissions    → rwx for owner, group, others
Owner          → User who owns it
Group          → Group who owns it
Timestamps     → Created, modified, accessed
Contents       → Actual data
```

**View all attributes:**
```bash
ls -la file.txt          # Long format shows most attributes
stat file.txt            # Detailed attribute information
file file.txt            # Determine file type
```

### File Types (First Character of ls -la)

```
-     Regular file (document, config, script, binary, etc)
d     Directory (folder)
l     Symbolic link (shortcut to another file)
b     Block device (hard drive, USB, etc)
c     Character device (terminal, serial port, etc)
s     Socket (inter-process communication)
p     Pipe (named pipe/FIFO)
```

**Example:**
```bash
-rw-r--r-- 1 alice users 1234 Jan 14 10:30 report.txt
# ^ Regular file

drwxr-xr-x 2 alice users 4096 Jan 14 10:30 documents/
# ^ Directory
```

### File Extensions

In Linux, extensions are **optional** and mostly for human reference:

```
file.txt       # Text file (but extension doesn't matter, content does)
script.sh      # Shell script (executable, but needs #!/bin/bash + permissions)
program        # No extension, could be anything
.bashrc        # Hidden file (starts with dot), no extension
```

**Important:** Linux doesn't rely on extensions. A file called `myfile` with executable permission IS a program, regardless of name.

### Hidden Files

Files starting with `.` are hidden:

```
.bashrc        ← Hidden (shell configuration)
.gitignore     ← Hidden (git configuration)
.ssh/          ← Hidden directory (SSH keys)
```

**Listing hidden files:**
```bash
ls -a          # Show all files including hidden
ls -la         # Long format including hidden
ls -la ..      # Hidden files in parent directory
```

---

## Command Structure and Syntax

### Anatomy of a Command

```
command [-options] [arguments]

Example:
ls -la /home/alice
│  │   │
│  │   └─ Argument: what to list
│  └──── Option: -l (long format), -a (all files)
└──────── Command: what to do
```

### Options (also called Flags or Switches)

**Short options** - Single letter with single dash:
```bash
ls -a           # -a option
ls -l           # -l option
ls -la          # -l and -a combined
```

**Long options** - Full word with double dash:
```bash
ls --all        # Same as -a (show all)
ls --human-readable  # -h option but long form
```

**Options with values:**
```bash
ls -w 120       # -w option with value 120
grep -n "error" # -n option, argument is "error"
```

### Arguments

Arguments are what the command operates on:

```bash
cp file1.txt file2.txt
   │        │
   │        └─ Argument 2: destination
   └────────── Argument 1: source

cat /home/alice/report.txt
    │
    └─ Argument: file to display
```

### Common Option Patterns

```bash
# Verbose - show what's happening
ls -v              # Tell me what you're doing

# Force - don't ask, just do it
rm -f file.txt     # Delete without asking

# Recursive - do this to directory and everything in it
rm -r directory/   # Delete directory and contents
cp -r source/ dest/  # Copy directory and everything

# Quiet - don't show output
cat file.txt 2>/dev/null  # Suppress errors

# Dry-run - show what would happen but don't do it
rm -i file.txt     # Ask before deleting (interactive)
```

### Return Values (Exit Codes)

Every command returns an exit code:

```bash
0      Command succeeded
1-255  Command failed (different codes mean different errors)

# Check exit code
echo $?            # Show exit code of last command

# Example
ls /tmp            # Probably succeeds
echo $?            # Shows 0

ls /nonexistent    # Fails
echo $?            # Shows 2 (not found error)
```

---

## Environment Variables

### What are Environment Variables?

Environment variables are named values that the shell uses for configuration. They're passed to all programs that run.

```bash
PATH               → Where shell looks for commands
HOME               → Your home directory
USER               → Your username
SHELL              → Which shell you're using
PWD                → Current directory
LANG               → Language/locale settings
```

### Viewing Environment Variables

```bash
echo $HOME         # Show specific variable
env                # Show all environment variables
set                # Show all variables (including local)
printenv           # Another way to show environment
```

### Common Environment Variables

| Variable | Purpose | Example |
|----------|---------|---------|
| `$HOME` | Home directory | `/home/alice` |
| `$USER` | Current username | `alice` |
| `$UID` | Current user ID | `1000` |
| `$PWD` | Current working directory | `/home/alice/documents` |
| `$OLDPWD` | Previous working directory | `/home/alice` |
| `$PATH` | Directories to search for commands | `/usr/bin:/bin:/usr/sbin:/sbin` |
| `$SHELL` | Current shell | `/bin/bash` |
| `$LANG` | Language setting | `en_US.UTF-8` |
| `$TERM` | Terminal type | `xterm-256color` |
| `$HISTSIZE` | History lines to remember | `1000` |

### Setting Variables

**Temporary (current session only):**
```bash
export MYVAR="value"        # Set and export (available to programs)
MYVAR="value"               # Set but not export (local only)
echo $MYVAR                 # Use it
```

**Permanent (add to ~/.bashrc):**
```bash
echo 'export MYVAR="value"' >> ~/.bashrc
source ~/.bashrc            # Reload configuration
```

### How PATH Works

When you type a command, the shell searches PATH for it:

```bash
echo $PATH
# Output: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin

# Shell looks in each directory in order:
# 1. /usr/local/bin     (custom programs)
# 2. /usr/bin           (most user programs)
# 3. /bin               (essential programs)
# 4. /usr/sbin          (system programs, need sudo)
# 5. /sbin              (essential system programs)

# First match wins, so:
which python3              # Shows which python it would run
/usr/bin/python3           # It's in /usr/bin
```

---

## Standard Streams: Input, Output, Error

### The Three Streams

Every process in Linux has three standard streams:

```
stdin (0)   → Input source (usually your keyboard)
stdout (1)  → Output destination (usually your terminal)
stderr (2)  → Error destination (also usually your terminal)

Program
  ↓
[stdin]  ← Data comes in
  ↓
[Process]
  ↓
[stdout] → Normal output
[stderr] → Error messages
```

### Examples

```bash
cat file.txt
# stdin: keyboard (waiting for input if no file)
# stdout: contents of file.txt
# stderr: nothing (no error)

cat /nonexistent
# stdin: keyboard
# stdout: nothing
# stderr: "No such file or directory"
```

---

## Pipes and Redirection

### Redirection Operators

```bash
>   Redirect stdout to file (overwrite)
>>  Redirect stdout to file (append)
<   Redirect stdin from file
2>  Redirect stderr to file
2>> Redirect stderr to file (append)
2>&1 Combine stderr with stdout
&   Run in background
|   Pipe (send output to another command)
```

### Examples

```bash
ls > files.txt           # Save file list to files.txt (overwrite)
ls >> files.txt          # Append file list to files.txt
cat < input.txt          # Read from file instead of keyboard
grep error logfile 2>err.txt  # Save errors to err.txt
ls 2>&1 | tee output.txt # Save both output and errors
```

### Pipes

```bash
ls | grep "\.txt"        # Send ls output to grep
# Output of ls → Input of grep

cat file.txt | head -n 5 | tail -n 1  # Show 5th line
# cat → head → tail → screen
```

---

## Wildcards and Globbing

### Wildcard Patterns

```bash
*     Any characters (0 or more)
?     Any single character
[ ]   Any character in brackets
[! ]  Any character NOT in brackets
```

### Examples

```bash
*.txt              # All files ending in .txt
file?.txt          # file1.txt, fileA.txt, file_.txt, etc
[abc]*             # Files starting with a, b, or c
[0-9]*             # Files starting with number
[!aeiou]*          # Files NOT starting with vowel
file[1-3].txt      # file1.txt, file2.txt, or file3.txt
```

### Practical Examples

```bash
ls *.log           # List all .log files
cp data/*.csv backup/  # Copy all .csv files
rm -i [0-9]*       # Delete (asking) all files starting with number
find . -name "*.tmp"   # Find all .tmp files recursively
```

### Important Gotcha

```bash
# Wildcards are expanded by the SHELL, not the command
ls *               # Shell expands * to all files, passes list to ls
                   # Same as: ls file1.txt file2.txt file3.txt

grep "error" *     # Shell expands *, then grep gets each file
                   # Same as: grep "error" file1.txt file2.txt...
```

---

## Mental Models for Success

### The Filesystem Tree
Think of the filesystem as a real tree:
- `/` is the trunk
- `/home`, `/usr`, `/etc` are branches
- Files are leaves
- Use `cd` to climb/descend, `ls` to see what's around

### Commands as Verbs
```
ls    → Look/List
cd    → Go/Move
cat   → Read
cp    → Copy
mv    → Move
rm    → Delete
grep  → Search
find  → Seek
echo  → Say/Print
```

### Permissions as Security
```
Permission = Door Lock
Owner gets a key (full access)
Group members get a key (limited)
Others get a key (very limited)
Think carefully before opening doors (777)
```

### Paths as Addresses
```
Absolute paths are like full mailing addresses (work from anywhere)
Relative paths are like local directions (only work from specific location)
```

---

## Summary: What You Now Know

✅ The Linux filesystem structure and what each directory contains
✅ How shells work and interpret commands
✅ The permission system (rwx) and who gets access
✅ Absolute vs relative paths and when to use each
✅ File attributes and file types
✅ Command syntax and structure
✅ Environment variables and how the system uses them
✅ Standard streams and how data flows
✅ Pipes and redirection for powerful combinations
✅ Wildcards for pattern matching

---

**Next Step:** Move to [02-commands-cheatsheet.md](02-commands-cheatsheet.md) to learn specific commands with examples.

**Key Takeaway:** Linux is powerful because it's consistent. Once you understand these concepts, the commands follow logical patterns and you can reason about what they'll do.
